From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 3 Mar 2016 04:00:11 -0600
Subject: [PATCH] Timings v2


diff --git a/src/main/java/net/minecraft/commands/CommandFunction.java b/src/main/java/net/minecraft/commands/CommandFunction.java
index ca1a9884ab09fc7e575b1d30e2dd0aaff324fb73..b94038e2da0f986403c1ec9b27384344e2bb22f0 100644
--- a/src/main/java/net/minecraft/commands/CommandFunction.java
+++ b/src/main/java/net/minecraft/commands/CommandFunction.java
@@ -16,6 +16,15 @@ import net.minecraft.server.ServerFunctionManager;
 public class CommandFunction {
     private final CommandFunction.Entry[] entries;
     final ResourceLocation id;
+    // Paper start
+    public co.aikar.timings.Timing timing;
+    public co.aikar.timings.Timing getTiming() {
+        if (timing == null) {
+            timing = co.aikar.timings.MinecraftTimings.getCommandFunctionTiming(this);
+        }
+        return timing;
+    }
+    // Paper end
 
     public CommandFunction(ResourceLocation id, CommandFunction.Entry[] elements) {
         this.id = id;
diff --git a/src/main/java/net/minecraft/network/protocol/PacketUtils.java b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
index 13421daa96b4ba302581f36abcd730952713d8cd..049e64c355d5f064009b1107ad15d28c44f999dd 100644
--- a/src/main/java/net/minecraft/network/protocol/PacketUtils.java
+++ b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
@@ -26,7 +26,8 @@ public class PacketUtils {
             engine.executeIfPossible(() -> {
                 if (MinecraftServer.getServer().hasStopped() || (listener instanceof ServerGamePacketListenerImpl && ((ServerGamePacketListenerImpl) listener).processedDisconnect)) return; // CraftBukkit, MC-142590
                 if (listener.getConnection().isConnected()) {
-                    try {
+                    co.aikar.timings.Timing timing = co.aikar.timings.MinecraftTimings.getPacketTiming(packet); // Paper - timings
+                    try (co.aikar.timings.Timing ignored = timing.startTiming()) { // Paper - timings
                         packet.handle(listener);
                     } catch (Exception exception) {
                         if (listener.shouldPropagateHandlingExceptions()) {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 1ad7797dbef61f8e8011ae6db3089939a279071c..1190d62594c5b1be1c11d55e646ee0bac27307cb 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -175,7 +175,7 @@ import org.bukkit.craftbukkit.generator.CustomWorldChunkManager;
 import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
-import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import co.aikar.timings.MinecraftTimings; // Paper
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements CommandSource, AutoCloseable {
 
@@ -851,6 +851,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         MinecraftServer.LOGGER.info("Stopping server");
+        MinecraftTimings.stopServer(); // Paper
         // CraftBukkit start
         if (this.server != null) {
             this.server.disablePlugins();
@@ -1094,9 +1095,21 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     private boolean haveTime() {
         // CraftBukkit start
+        if (isOversleep) return canOversleep();// Paper - because of our changes, this logic is broken
         return this.forceTicks || this.runningTask() || Util.getMillis() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTime : this.nextTickTime);
     }
 
+    // Paper start
+    boolean isOversleep = false;
+    private boolean canOversleep() {
+        return this.mayHaveDelayedTasks && Util.getMillis() < this.delayedTasksMaxNextTickTime;
+    }
+
+    private boolean canSleepForTickNoOversleep() {
+        return this.forceTicks || this.runningTask() || Util.getMillis() < this.nextTickTime;
+    }
+    // Paper end
+
     private void executeModerately() {
         this.runAllTasks();
         java.util.concurrent.locks.LockSupport.parkNanos("executing tasks", 1000L);
@@ -1104,9 +1117,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // CraftBukkit end
 
     protected void waitUntilNextTick() {
-        this.runAllTasks();
+        //this.executeAll(); // Paper - move this into the tick method for timings
         this.managedBlock(() -> {
-            return !this.haveTime();
+            return !this.canSleepForTickNoOversleep(); // Paper - move oversleep into full server tick
         });
     }
 
@@ -1192,9 +1205,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public void onServerExit() {}
 
     public void tickServer(BooleanSupplier shouldKeepTicking) {
-        SpigotTimings.serverTickTimer.startTiming(); // Spigot
+        co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         long i = Util.getNanos();
 
+        // Paper start - move oversleep into full server tick
+        isOversleep = true;MinecraftTimings.serverOversleep.startTiming();
+        this.managedBlock(() -> {
+            return !this.canOversleep();
+        });
+        isOversleep = false;MinecraftTimings.serverOversleep.stopTiming();
+        // Paper end
+
         ++this.tickCount;
         this.tickChildren(shouldKeepTicking);
         if (i - this.lastServerStatus >= 5000000000L) {
@@ -1220,15 +1241,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         if (this.autosavePeriod > 0 && this.tickCount % this.autosavePeriod == 0) { // CraftBukkit
-            SpigotTimings.worldSaveTimer.startTiming(); // Spigot
             MinecraftServer.LOGGER.debug("Autosave started");
             this.profiler.push("save");
             this.saveEverything(true, false, false);
             this.profiler.pop();
             MinecraftServer.LOGGER.debug("Autosave finished");
-            SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
         }
         io.papermc.paper.util.CachedLists.reset(); // Paper
+        // Paper start - move executeAll() into full server tick timing
+        try (co.aikar.timings.Timing ignored = MinecraftTimings.processTasksTimer.startTiming()) {
+            this.runAllTasks();
+        }
+        // Paper end
         this.profiler.push("tallying");
         long l = this.tickTimes[this.tickCount % 100] = Util.getNanos() - i;
 
@@ -1238,30 +1262,29 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.frameTimer.logFrameDuration(i1 - i);
         this.profiler.pop();
         org.spigotmc.WatchdogThread.tick(); // Spigot
-        SpigotTimings.serverTickTimer.stopTiming(); // Spigot
-        org.spigotmc.CustomTimingsHandler.tick(); // Spigot
+        co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
     }
 
     public void tickChildren(BooleanSupplier shouldKeepTicking) {
-        SpigotTimings.schedulerTimer.startTiming(); // Spigot
+        MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
         this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // CraftBukkit
-        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
+        MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Spigot // Paper
         this.profiler.push("commandFunctions");
-        SpigotTimings.commandFunctionsTimer.startTiming(); // Spigot
+        MinecraftTimings.commandFunctionsTimer.startTiming(); // Spigot // Paper
         this.getFunctions().tick();
-        SpigotTimings.commandFunctionsTimer.stopTiming(); // Spigot
+        MinecraftTimings.commandFunctionsTimer.stopTiming(); // Spigot // Paper
         this.profiler.popPush("levels");
         Iterator iterator = this.getAllLevels().iterator();
 
         // CraftBukkit start
         // Run tasks that are waiting on processing
-        SpigotTimings.processQueueTimer.startTiming(); // Spigot
+        MinecraftTimings.processQueueTimer.startTiming(); // Spigot
         while (!this.processQueue.isEmpty()) {
             this.processQueue.remove().run();
         }
-        SpigotTimings.processQueueTimer.stopTiming(); // Spigot
+        MinecraftTimings.processQueueTimer.stopTiming(); // Spigot
 
-        SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
+        MinecraftTimings.timeUpdateTimer.startTiming(); // Spigot // Paper
         // Send time updates to everyone, it will get the right time from the world the player is in.
         if (this.tickCount % 20 == 0) {
             for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
@@ -1269,7 +1292,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 entityplayer.connection.send(new ClientboundSetTimePacket(entityplayer.level.getGameTime(), entityplayer.getPlayerTime(), entityplayer.level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT))); // Add support for per player time
             }
         }
-        SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
+        MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
 
         while (iterator.hasNext()) {
             ServerLevel worldserver = (ServerLevel) iterator.next();
@@ -1315,24 +1338,24 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         this.profiler.popPush("connection");
-        SpigotTimings.connectionTimer.startTiming(); // Spigot
+        MinecraftTimings.connectionTimer.startTiming(); // Spigot
         this.getConnection().tick();
-        SpigotTimings.connectionTimer.stopTiming(); // Spigot
+        MinecraftTimings.connectionTimer.stopTiming(); // Spigot
         this.profiler.popPush("players");
-        SpigotTimings.playerListTimer.startTiming(); // Spigot
+        MinecraftTimings.playerListTimer.startTiming(); // Spigot // Paper
         this.playerList.tick();
-        SpigotTimings.playerListTimer.stopTiming(); // Spigot
+        MinecraftTimings.playerListTimer.stopTiming(); // Spigot // Paper
         if (SharedConstants.IS_RUNNING_IN_IDE) {
             GameTestTicker.SINGLETON.tick();
         }
 
         this.profiler.popPush("server gui refresh");
 
-        SpigotTimings.tickablesTimer.startTiming(); // Spigot
+        MinecraftTimings.tickablesTimer.startTiming(); // Spigot // Paper
         for (int i = 0; i < this.tickables.size(); ++i) {
             ((Runnable) this.tickables.get(i)).run();
         }
-        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
+        MinecraftTimings.tickablesTimer.stopTiming(); // Spigot // Paper
 
         this.profiler.pop();
     }
diff --git a/src/main/java/net/minecraft/server/ServerFunctionManager.java b/src/main/java/net/minecraft/server/ServerFunctionManager.java
index b7a06306614087dfab4d4dcf83797b5a92c376c5..00a50196f6a4768d84acfbbeec79a0753308f091 100644
--- a/src/main/java/net/minecraft/server/ServerFunctionManager.java
+++ b/src/main/java/net/minecraft/server/ServerFunctionManager.java
@@ -88,7 +88,7 @@ public class ServerFunctionManager {
         } else {
             int i;
 
-            try {
+            try (co.aikar.timings.Timing timing = function.getTiming().startTiming()) { // Paper
                 this.context = new ServerFunctionManager.ExecutionContext(tracer);
                 i = this.context.runTopCommand(function, source);
             } finally {
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 408eff59b081ace53bf435947df17e2fe75bfd5e..cd0365249dffc1704a349a5e419364bbf9e8543b 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -63,8 +63,9 @@ import org.apache.logging.log4j.Level;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.io.IoBuilder;
 import org.bukkit.command.CommandSender;
-import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import co.aikar.timings.MinecraftTimings; // Paper
 import org.bukkit.event.server.ServerCommandEvent;
+import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
 // CraftBukkit end
 
@@ -410,7 +411,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     }
 
     public void handleConsoleInputs() {
-        SpigotTimings.serverCommandTimer.startTiming(); // Spigot
+        MinecraftTimings.serverCommandTimer.startTiming(); // Spigot
         while (!this.consoleInput.isEmpty()) {
             ConsoleInput servercommand = (ConsoleInput) this.consoleInput.remove(0);
 
@@ -425,7 +426,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             // CraftBukkit end
         }
 
-        SpigotTimings.serverCommandTimer.stopTiming(); // Spigot
+        MinecraftTimings.serverCommandTimer.stopTiming(); // Spigot
     }
 
     @Override
@@ -676,6 +677,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
 
     @Override
     public String runCommand(String command) {
+        Waitable[] waitableArray = new Waitable[1];
         this.rconConsoleSource.prepareForCommand();
         this.executeBlocking(() -> {
             // CraftBukkit start - fire RemoteServerCommandEvent
@@ -684,10 +686,39 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             if (event.isCancelled()) {
                 return;
             }
+            // Paper start
+            if (command.toLowerCase().startsWith("timings") && command.toLowerCase().matches("timings (report|paste|get|merged|seperate)")) {
+                org.bukkit.command.BufferedCommandSender sender = new org.bukkit.command.BufferedCommandSender();
+                Waitable<String> waitable = new Waitable<String>() {
+                    @Override
+                    protected String evaluate() {
+                        return sender.getBuffer();
+                    }
+                };
+                waitableArray[0] = waitable;
+                co.aikar.timings.Timings.generateReport(new co.aikar.timings.TimingsReportListener(sender, waitable));
+            } else {
+            // Paper end
             ConsoleInput serverCommand = new ConsoleInput(event.getCommand(), this.rconConsoleSource.createCommandSourceStack());
             server.dispatchServerCommand(remoteConsole, serverCommand);
+            } // Paper
             // CraftBukkit end
         });
+        // Paper start
+        if (waitableArray[0] != null) {
+            //noinspection unchecked
+            Waitable<String> waitable = waitableArray[0];
+            try {
+                return waitable.get();
+            } catch (java.util.concurrent.ExecutionException e) {
+                throw new RuntimeException("Exception processing rcon command " + command, e.getCause());
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt(); // Maintain interrupted state
+                throw new RuntimeException("Interrupted processing rcon command " + command, e);
+            }
+
+        }
+        // Paper end
         return this.rconConsoleSource.getCommandResponse();
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 91fd4243416c41b1c2b0f0f1abc154064c164a25..e01d86c50e0227cfae91ba8022b763e51a10c5f5 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1,8 +1,10 @@
 package net.minecraft.server.level;
 
+import co.aikar.timings.Timing; // Paper
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
@@ -853,6 +855,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             ChunkStatus chunkstatus = ChunkHolder.getStatus(chunkHolder.getTicketLevel());
 
             return !chunkstatus.isOrAfter(ChunkStatus.FULL) ? ChunkHolder.UNLOADED_CHUNK : either.mapLeft((ichunkaccess) -> {
+                try (Timing ignored = level.timings.chunkPostLoad.startTimingIfSync()) { // Paper
                 ChunkPos chunkcoordintpair = chunkHolder.getPos();
                 ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
                 LevelChunk chunk;
@@ -877,6 +880,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 }
 
                 return chunk;
+                } // Paper
             });
         }, (runnable) -> {
             ProcessorHandle mailbox = this.mainThreadMailbox;
@@ -1429,6 +1433,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         List<ServerPlayer> list = Lists.newArrayList();
         List<ServerPlayer> list1 = this.level.players();
         ObjectIterator objectiterator = this.entityMap.values().iterator();
+        level.timings.tracker1.startTiming(); // Paper
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker;
 
@@ -1453,14 +1458,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 playerchunkmap_entitytracker.serverEntity.sendChanges();
             }
         }
+        level.timings.tracker1.stopTiming(); // Paper
 
         if (!list.isEmpty()) {
             objectiterator = this.entityMap.values().iterator();
 
+            level.timings.tracker2.startTiming(); // Paper
             while (objectiterator.hasNext()) {
                 playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
                 playerchunkmap_entitytracker.updatePlayers(list);
             }
+            level.timings.tracker2.stopTiming(); // Paper
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 186a8f5895fedbaf27a7949d9bdbb1a9f2e36fbf..86acdd910eebb8beac4536942119c9e97580ff2e 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -517,13 +517,15 @@ public class ServerChunkCache extends ChunkSource {
             }
 
             gameprofilerfiller.incrementCounter("getChunkCacheMiss");
-            level.timings.syncChunkLoadTimer.startTiming(); // Spigot
             CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkFutureMainThread(x, z, leastStatus, create);
             ServerChunkCache.MainThreadExecutor chunkproviderserver_b = this.mainThreadProcessor;
 
             Objects.requireNonNull(completablefuture);
+            if (!completablefuture.isDone()) { // Paper
+                this.level.timings.syncChunkLoad.startTiming(); // Paper
             chunkproviderserver_b.managedBlock(completablefuture::isDone);
-            level.timings.syncChunkLoadTimer.stopTiming(); // Spigot
+                this.level.timings.syncChunkLoad.stopTiming(); // Paper
+            } // Paper
             ichunkaccess = (ChunkAccess) ((Either) completablefuture.join()).map((ichunkaccess1) -> {
                 return ichunkaccess1;
             }, (playerchunk_failure) -> {
@@ -721,7 +723,9 @@ public class ServerChunkCache extends ChunkSource {
 
     public void save(boolean flush) {
         this.runDistanceManagerUpdates();
+        try (co.aikar.timings.Timing timed = level.timings.chunkSaveData.startTiming()) { // Paper - Timings
         this.chunkMap.saveAllChunks(flush);
+        } // Paper - Timings
     }
 
     @Override
@@ -760,7 +764,9 @@ public class ServerChunkCache extends ChunkSource {
         this.level.timings.doChunkMap.stopTiming(); // Spigot
         this.level.getProfiler().popPush("chunks");
         if (tickChunks) {
+            this.level.timings.chunks.startTiming(); // Paper - timings
             this.tickChunks();
+            this.level.timings.chunks.stopTiming(); // Paper - timings
         }
 
         this.level.timings.doChunkUnload.startTiming(); // Spigot
@@ -789,13 +795,16 @@ public class ServerChunkCache extends ChunkSource {
             boolean flag1 = level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) != 0L && worlddata.getGameTime() % level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) == 0L; // CraftBukkit
 
             gameprofilerfiller.push("naturalSpawnCount");
+            this.level.timings.countNaturalMobs.startTiming(); // Paper - timings
             int l = this.distanceManager.getNaturalSpawnChunkCount();
             NaturalSpawner.SpawnState spawnercreature_d = NaturalSpawner.createState(l, this.level.getAllEntities(), this::getFullChunk, new LocalMobCapCalculator(this.chunkMap));
+            this.level.timings.countNaturalMobs.stopTiming(); // Paper - timings
 
             this.lastSpawnState = spawnercreature_d;
             gameprofilerfiller.popPush("filteringLoadedChunks");
             List<ServerChunkCache.ChunkAndHolder> list = Lists.newArrayListWithCapacity(l);
             Iterator iterator = this.chunkMap.getChunks().iterator();
+            this.level.timings.chunkTicks.startTiming(); // Paper
 
             while (iterator.hasNext()) {
                 ChunkHolder playerchunk = (ChunkHolder) iterator.next();
@@ -824,27 +833,27 @@ public class ServerChunkCache extends ChunkSource {
                     }
 
                     if (this.level.shouldTickBlocksAt(chunkcoordintpair.toLong())) {
-                        this.level.timings.doTickTiles.startTiming(); // Spigot
                         this.level.tickChunk(chunk1, k);
-                        this.level.timings.doTickTiles.stopTiming(); // Spigot
                     }
                 }
             }
-
+            this.level.timings.chunkTicks.stopTiming(); // Paper
             gameprofilerfiller.popPush("customSpawners");
             if (flag2) {
+                try (co.aikar.timings.Timing ignored = this.level.timings.miscMobSpawning.startTiming()) { // Paper - timings
                 this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
+                } // Paper - timings
             }
 
             gameprofilerfiller.popPush("broadcast");
             list.forEach((chunkproviderserver_a1) -> {
+                this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing
                 chunkproviderserver_a1.holder.broadcastChanges(chunkproviderserver_a1.chunk);
+                this.level.timings.broadcastChunkUpdates.stopTiming(); // Paper - timing
             });
             gameprofilerfiller.pop();
             gameprofilerfiller.pop();
-            this.level.timings.tracker.startTiming(); // Spigot
             this.chunkMap.tick();
-            this.level.timings.tracker.stopTiming(); // Spigot
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 58da012345126bbfc9980538adf3f79bd87412bb..a14386502e9b3ccec23233db2ddfedeec94ffb91 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -1,6 +1,8 @@
 package net.minecraft.server.level;
 
 import com.google.common.annotations.VisibleForTesting;
+import co.aikar.timings.TimingHistory; // Paper
+import co.aikar.timings.Timings; // Paper
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
@@ -156,7 +158,6 @@ import org.slf4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.WeatherType;
-import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.generator.CustomWorldChunkManager;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
@@ -446,7 +447,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         this.updateSkyBrightness();
         this.tickTime();
         gameprofilerfiller.popPush("tickPending");
-        timings.doTickPending.startTiming(); // Spigot
+        timings.scheduledBlocks.startTiming(); // Paper
         if (!this.isDebug()) {
             j = this.getGameTime();
             gameprofilerfiller.push("blockTicks");
@@ -455,12 +456,16 @@ public class ServerLevel extends Level implements WorldGenLevel {
             this.fluidTicks.tick(j, 65536, this::tickFluid);
             gameprofilerfiller.pop();
         }
-        timings.doTickPending.stopTiming(); // Spigot
+        timings.scheduledBlocks.stopTiming(); // Paper
 
         gameprofilerfiller.popPush("raid");
+        this.timings.raids.startTiming(); // Paper - timings
         this.raids.tick();
+        this.timings.raids.stopTiming(); // Paper - timings
         gameprofilerfiller.popPush("chunkSource");
+        this.timings.chunkProviderTick.startTiming(); // Paper - timings
         this.getChunkSource().tick(shouldKeepTicking, true);
+        this.timings.chunkProviderTick.stopTiming(); // Paper - timings
         gameprofilerfiller.popPush("blockEvents");
         timings.doSounds.startTiming(); // Spigot
         this.runBlockEvents();
@@ -627,6 +632,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         gameprofilerfiller.popPush("tickBlocks");
+        timings.chunkTicksBlocks.startTiming(); // Paper
         if (randomTickSpeed > 0) {
             LevelChunkSection[] achunksection = chunk.getSections();
             int l = achunksection.length;
@@ -659,6 +665,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
         }
 
+        timings.chunkTicksBlocks.stopTiming(); // Paper
         gameprofilerfiller.pop();
     }
 
@@ -893,14 +900,22 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     public void tickNonPassenger(Entity entity) {
+        ++TimingHistory.entityTicks; // Paper - timings
         // Spigot start
+        co.aikar.timings.Timing timer; // Paper
         if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
             entity.tickCount++;
+            timer = entity.getType().inactiveTickTimer.startTiming(); try { // Paper - timings
             entity.inactiveTick();
+            } finally { timer.stopTiming(); } // Paper
             return;
         }
         // Spigot end
-        entity.tickTimer.startTiming(); // Spigot
+        // Paper start- timings
+        TimingHistory.activatedEntityTicks++;
+        timer = entity.getVehicle() != null ? entity.getType().passengerTickTimer.startTiming() : entity.getType().tickTimer.startTiming();
+        try {
+        // Paper end - timings
         entity.setOldPosAndRot();
         ProfilerFiller gameprofilerfiller = this.getProfiler();
 
@@ -919,7 +934,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
             this.tickPassenger(entity, entity1);
         }
-        entity.tickTimer.stopTiming(); // Spigot
+        } finally { timer.stopTiming(); } // Paper - timings
 
     }
 
@@ -961,6 +976,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         if (!savingDisabled) {
             org.bukkit.Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(getWorld())); // CraftBukkit
+            try (co.aikar.timings.Timing ignored = timings.worldSave.startTiming()) { // Paper
             if (progressListener != null) {
                 progressListener.progressStartNoAbort(Component.translatable("menu.savingLevel"));
             }
@@ -970,7 +986,10 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 progressListener.progressStage(Component.translatable("menu.savingChunks"));
             }
 
+                timings.worldSaveChunks.startTiming(); // Paper
             chunkproviderserver.save(flush);
+                timings.worldSaveChunks.stopTiming(); // Paper
+            }// Paper
             if (flush) {
                 this.entityManager.saveAll();
             } else {
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index a22008c6534c78a751dcd69f217db305b13d2c56..357ff7f3ade2d59a7a2b3d93d7d35534565b6add 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -311,7 +311,6 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     // CraftBukkit end
 
     public void tick() {
-        org.bukkit.craftbukkit.SpigotTimings.playerConnectionTimer.startTiming(); // Spigot
         if (this.ackBlockChangesUpTo > -1) {
             this.send(new ClientboundBlockChangedAckPacket(this.ackBlockChangesUpTo));
             this.ackBlockChangesUpTo = -1;
@@ -392,7 +391,6 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
             this.player.resetLastActionTime(); // CraftBukkit - SPIGOT-854
             this.disconnect(Component.translatable("multiplayer.disconnect.idling"));
         }
-        org.bukkit.craftbukkit.SpigotTimings.playerConnectionTimer.stopTiming(); // Spigot
 
         this.chatPreviewThrottler.tick();
     }
@@ -2022,7 +2020,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     }
 
     private void handleCommand(String s) {
-        org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.startTiming(); // Spigot
+        co.aikar.timings.MinecraftTimings.playerCommandTimer.startTiming(); // Paper
         if ( org.spigotmc.SpigotConfig.logCommands ) // Spigot
         this.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + s);
 
@@ -2032,7 +2030,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
         this.cserver.getPluginManager().callEvent(event);
 
         if (event.isCancelled()) {
-            org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
+            co.aikar.timings.MinecraftTimings.playerCommandTimer.stopTiming(); // Paper
             return;
         }
 
@@ -2045,7 +2043,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
             java.util.logging.Logger.getLogger(ServerGamePacketListenerImpl.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
             return;
         } finally {
-            org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
+            co.aikar.timings.MinecraftTimings.playerCommandTimer.stopTiming(); // Paper
         }
     }
     // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 9e0c61b63cc402c26ca1306313ca6054efb108b8..dbd53de61057eb9eb8be651abf9abcad18423ab1 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -1,5 +1,6 @@
 package net.minecraft.server.players;
 
+import co.aikar.timings.MinecraftTimings;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -1017,10 +1018,11 @@ public abstract class PlayerList {
     }
 
     public void saveAll() {
+        MinecraftTimings.savePlayers.startTiming(); // Paper
         for (int i = 0; i < this.players.size(); ++i) {
             this.save((ServerPlayer) this.players.get(i));
         }
-
+        MinecraftTimings.savePlayers.stopTiming(); // Paper
     }
 
     public UserWhiteList getWhiteList() {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 3def476eee5fd6065762bdebd6659a3cc1a8dfbc..e6a884fb477f66502c3ce3091e8123f3370188ff 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -132,7 +132,6 @@ import org.bukkit.craftbukkit.event.CraftPortalEvent;
 import org.bukkit.entity.Hanging;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Vehicle;
-import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.hanging.HangingBreakByEntityEvent;
 import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
@@ -299,7 +298,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public boolean lastDamageCancelled; // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Keep track if the event was canceled
     public boolean persistentInvisibility = false;
     public BlockPos lastLavaContact;
-    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getEntityTimings(this); // Spigot
     // Spigot start
     public final org.spigotmc.ActivationRange.ActivationType activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
     public final boolean defaultActivationState;
@@ -749,7 +747,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     public void move(MoverType movementType, Vec3 movement) {
-        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
         if (this.noPhysics) {
             this.setPos(this.getX() + movement.x, this.getY() + movement.y, this.getZ() + movement.z);
         } else {
@@ -913,7 +910,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                 this.level.getProfiler().pop();
             }
         }
-        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
     }
 
     protected boolean isHorizontalCollisionMinor(Vec3 adjustedMovement) {
diff --git a/src/main/java/net/minecraft/world/entity/EntityType.java b/src/main/java/net/minecraft/world/entity/EntityType.java
index cdf8020194f2ec1fe7b65b22c8e1f5b1c23eaefa..2db27f5e3e3c1bb0502c055f78c4a81eb00fcf1b 100644
--- a/src/main/java/net/minecraft/world/entity/EntityType.java
+++ b/src/main/java/net/minecraft/world/entity/EntityType.java
@@ -305,7 +305,14 @@ public class EntityType<T extends Entity> implements EntityTypeTest<Entity, T> {
         return Registry.ENTITY_TYPE.getOptional(ResourceLocation.tryParse(id));
     }
 
+    // Paper start - add id
+    public final String id;
+
     public EntityType(EntityType.EntityFactory<T> factory, MobCategory spawnGroup, boolean saveable, boolean summonable, boolean fireImmune, boolean spawnableFarFromPlayer, ImmutableSet<Block> canSpawnInside, EntityDimensions dimensions, int maxTrackDistance, int trackTickInterval) {
+        this(factory, spawnGroup, saveable, summonable, fireImmune, spawnableFarFromPlayer, canSpawnInside, dimensions, maxTrackDistance, trackTickInterval, "custom");
+    }
+    public EntityType(EntityType.EntityFactory<T> factory, MobCategory spawnGroup, boolean saveable, boolean summonable, boolean fireImmune, boolean spawnableFarFromPlayer, ImmutableSet<Block> canSpawnInside, EntityDimensions dimensions, int maxTrackDistance, int trackTickInterval, String id) {
+        // Paper end
         this.builtInRegistryHolder = Registry.ENTITY_TYPE.createIntrusiveHolder(this);
         this.factory = factory;
         this.category = spawnGroup;
@@ -317,6 +324,14 @@ public class EntityType<T extends Entity> implements EntityTypeTest<Entity, T> {
         this.dimensions = dimensions;
         this.clientTrackingRange = maxTrackDistance;
         this.updateInterval = trackTickInterval;
+
+        // Paper start - timings
+        this.id = id;
+        this.tickTimer = co.aikar.timings.MinecraftTimings.getEntityTimings(id, "tick");
+        this.inactiveTickTimer = co.aikar.timings.MinecraftTimings.getEntityTimings(id, "inactiveTick");
+        this.passengerTickTimer = co.aikar.timings.MinecraftTimings.getEntityTimings(id, "passengerTick");
+        this.passengerInactiveTickTimer = co.aikar.timings.MinecraftTimings.getEntityTimings(id, "passengerInactiveTick");
+        // Paper end
     }
 
     @Nullable
@@ -567,6 +582,12 @@ public class EntityType<T extends Entity> implements EntityTypeTest<Entity, T> {
         return this.updateInterval;
     }
 
+    // Paper start - timings
+    public final co.aikar.timings.Timing tickTimer;
+    public final co.aikar.timings.Timing inactiveTickTimer;
+    public final co.aikar.timings.Timing passengerTickTimer;
+    public final co.aikar.timings.Timing passengerInactiveTickTimer;
+    // Paper end
     public boolean trackDeltas() {
         return this != EntityType.PLAYER && this != EntityType.LLAMA_SPIT && this != EntityType.WITHER && this != EntityType.BAT && this != EntityType.ITEM_FRAME && this != EntityType.GLOW_ITEM_FRAME && this != EntityType.LEASH_KNOT && this != EntityType.PAINTING && this != EntityType.END_CRYSTAL && this != EntityType.EVOKER_FANGS;
     }
@@ -665,7 +686,7 @@ public class EntityType<T extends Entity> implements EntityTypeTest<Entity, T> {
                 Util.fetchChoiceType(References.ENTITY_TREE, id);
             }
 
-            return new EntityType<>(this.factory, this.category, this.serialize, this.summon, this.fireImmune, this.canSpawnFarFromPlayer, this.immuneTo, this.dimensions, this.clientTrackingRange, this.updateInterval);
+            return new EntityType<>(this.factory, this.category, this.serialize, this.summon, this.fireImmune, this.canSpawnFarFromPlayer, this.immuneTo, this.dimensions, this.clientTrackingRange, this.updateInterval, id); // Paper - add id
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 1f9701128aedb0343709866207f3044b890fe1be..3e1e2d9711c3c1b05406353f96d706c8abfe7a61 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -140,7 +140,7 @@ import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
 
-import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import co.aikar.timings.MinecraftTimings; // Paper
 
 public abstract class LivingEntity extends Entity {
 
@@ -2795,7 +2795,6 @@ public abstract class LivingEntity extends Entity {
 
     @Override
     public void tick() {
-        SpigotTimings.timerEntityBaseTick.startTiming(); // Spigot
         super.tick();
         this.updatingUsingItem();
         this.updateSwimAmount();
@@ -2836,9 +2835,7 @@ public abstract class LivingEntity extends Entity {
             }
         }
 
-        SpigotTimings.timerEntityBaseTick.stopTiming(); // Spigot
         this.aiStep();
-        SpigotTimings.timerEntityTickRest.startTiming(); // Spigot
         double d0 = this.getX() - this.xo;
         double d1 = this.getZ() - this.zo;
         float f = (float) (d0 * d0 + d1 * d1);
@@ -2918,8 +2915,6 @@ public abstract class LivingEntity extends Entity {
         if (this.isSleeping()) {
             this.setXRot(0.0F);
         }
-
-        SpigotTimings.timerEntityTickRest.stopTiming(); // Spigot
     }
 
     public void detectEquipmentUpdates() {
@@ -3101,7 +3096,6 @@ public abstract class LivingEntity extends Entity {
 
         this.setDeltaMovement(d4, d5, d6);
         this.level.getProfiler().push("ai");
-        SpigotTimings.timerEntityAI.startTiming(); // Spigot
         if (this.isImmobile()) {
             this.jumping = false;
             this.xxa = 0.0F;
@@ -3111,7 +3105,6 @@ public abstract class LivingEntity extends Entity {
             this.serverAiStep();
             this.level.getProfiler().pop();
         }
-        SpigotTimings.timerEntityAI.stopTiming(); // Spigot
 
         this.level.getProfiler().pop();
         this.level.getProfiler().push("jump");
@@ -3146,9 +3139,9 @@ public abstract class LivingEntity extends Entity {
         this.updateFallFlying();
         AABB axisalignedbb = this.getBoundingBox();
 
-        SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
+        // SpigotTimings.timerEntityAIMove.startTiming(); // Spigot // Paper
         this.travel(new Vec3((double) this.xxa, (double) this.yya, (double) this.zza));
-        SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
+        // SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot // Paper
         this.level.getProfiler().pop();
         this.level.getProfiler().push("freezing");
         boolean flag1 = this.getType().is(EntityTypeTags.FREEZE_HURTS_EXTRA_TYPES);
@@ -3177,9 +3170,7 @@ public abstract class LivingEntity extends Entity {
             this.checkAutoSpinAttack(axisalignedbb, this.getBoundingBox());
         }
 
-        SpigotTimings.timerEntityAICollision.startTiming(); // Spigot
         this.pushEntities();
-        SpigotTimings.timerEntityAICollision.stopTiming(); // Spigot
         this.level.getProfiler().pop();
         if (!this.level.isClientSide && this.isSensitiveToWater() && this.isInWaterRainOrBubble()) {
             this.hurt(DamageSource.DROWN, 1.0F);
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 0fa91ed5ed41c944f7398a88f9352742f34d4af5..39d64f3aeb998df5452699e098148d86fdd48c98 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -83,7 +83,6 @@ import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
-import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.craftbukkit.block.CapturedBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
@@ -157,7 +156,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     }
     // Paper end
 
-    public final SpigotTimings.WorldTimingsHandler timings; // Spigot
+    public final co.aikar.timings.WorldTimingsHandler timings; // Paper
     public static BlockPos lastPhysicsProblem; // Spigot
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
@@ -253,7 +252,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
             public void onBorderSetDamageSafeZOne(WorldBorder border, double safeZoneRadius) {}
         });
         // CraftBukkit end
-        this.timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings
+        timings = new co.aikar.timings.WorldTimingsHandler(this); // Paper - code below can generate new world and access timings
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
         this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
     }
@@ -689,15 +688,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
         timings.tileEntityTick.stopTiming(); // Spigot
         this.tickingBlockEntities = false;
+        co.aikar.timings.TimingHistory.tileEntityTicks += this.blockEntityTickers.size(); // Paper
         gameprofilerfiller.pop();
         spigotConfig.currentPrimedTnt = 0; // Spigot
     }
 
     public <T extends Entity> void guardEntityTick(Consumer<T> tickConsumer, T entity) {
         try {
-            SpigotTimings.tickEntityTimer.startTiming(); // Spigot
             tickConsumer.accept(entity);
-            SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.forThrowable(throwable, "Ticking entity");
             CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Entity being ticked");
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 950c468cad2937cd9a077a8f7a3d227662576a9a..60c5d4c97a340120f49f51b3d1dc7e6f2a19a936 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -91,6 +91,15 @@ public class Block extends BlockBehaviour implements ItemLike {
     public static final int UPDATE_LIMIT = 512;
     protected final StateDefinition<Block, BlockState> stateDefinition;
     private BlockState defaultBlockState;
+    // Paper start
+    public co.aikar.timings.Timing timing;
+    public co.aikar.timings.Timing getTiming() {
+        if (timing == null) {
+            timing = co.aikar.timings.MinecraftTimings.getBlockTiming(this);
+        }
+        return timing;
+    }
+    // Paper end
     @Nullable
     private String descriptionId;
     @Nullable
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index dec38e58e30c84887e9d29436c0f76c70c0a627d..be08224c8107aab3e9a3645a20977dd14bfff782 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -22,10 +22,12 @@ import org.bukkit.inventory.InventoryHolder;
 // CraftBukkit end
 
 import org.spigotmc.CustomTimingsHandler; // Spigot
+import co.aikar.timings.MinecraftTimings; // Paper
+import co.aikar.timings.Timing; // Paper
 
 public abstract class BlockEntity {
 
-    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getTileEntityTimings(this); // Spigot
+    public Timing tickTimer = MinecraftTimings.getTileEntityTimings(this); // Paper
     // CraftBukkit start - data containers
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
     public CraftPersistentDataContainer persistentDataContainer;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index ab986a3d1dc2f605b5b84d2b62cd97007e3a2c22..58a245b2ca6e65d491694142ad04d38236b46434 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -681,6 +681,7 @@ public class LevelChunk extends ChunkAccess {
             server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(this.bukkitChunk, this.needsDecoration));
 
             if (this.needsDecoration) {
+                try (co.aikar.timings.Timing ignored = this.level.timings.chunkLoadPopulate.startTiming()) { // Paper
                 this.needsDecoration = false;
                 java.util.Random random = new java.util.Random();
                 random.setSeed(this.level.getSeed());
@@ -700,6 +701,7 @@ public class LevelChunk extends ChunkAccess {
                     }
                 }
                 server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(this.bukkitChunk));
+                } // Paper
             }
         }
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
index 98ba88896c73651591b8ad8e070868fb443ae999..864e2e0355a5fb8c1d4a5b0896ba299faf9ea534 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -507,13 +507,10 @@ public class ChunkSerializer {
         ListTag nbttaglist1 = ChunkSerializer.getListOfCompoundsOrNull(nbt, "block_entities");
 
         return nbttaglist == null && nbttaglist1 == null ? null : (chunk) -> {
-            world.timings.syncChunkLoadEntitiesTimer.startTiming(); // Spigot
             if (nbttaglist != null) {
                 world.addLegacyChunkEntities(EntityType.loadEntitiesRecursive(nbttaglist, world));
             }
-            world.timings.syncChunkLoadEntitiesTimer.stopTiming(); // Spigot
 
-            world.timings.syncChunkLoadTileEntitiesTimer.startTiming(); // Spigot
             if (nbttaglist1 != null) {
                 for (int i = 0; i < nbttaglist1.size(); ++i) {
                     CompoundTag nbttagcompound1 = nbttaglist1.getCompound(i);
@@ -531,7 +528,6 @@ public class ChunkSerializer {
                     }
                 }
             }
-            world.timings.syncChunkLoadTileEntitiesTimer.stopTiming(); // Spigot
 
         };
     }
